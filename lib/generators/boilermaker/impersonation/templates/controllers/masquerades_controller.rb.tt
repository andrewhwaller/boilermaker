# frozen_string_literal: true

class MasqueradesController < ApplicationController
  before_action :authorize_admin, only: :create
  before_action :authorize_impersonation_exit, only: :destroy
  before_action :set_user, only: :create

  # POST /users/:user_id/masquerade
  def create
    if @user.app_admin?
      redirect_to admin_users_path, alert: "Cannot impersonate other administrators"
      return
    end

    # Create new session as the impersonated user, tracking the original admin
    session_record = @user.sessions.create!(
      user_agent: request.user_agent,
      ip_address: request.remote_ip,
      impersonator: Current.user
    )

    cookies.signed.permanent[:session_token] = { value: session_record.id, httponly: true }

    log_impersonation_start(@user) if respond_to?(:log_impersonation_start, true)

    redirect_to root_path, notice: "Now masquerading as #{@user.email}"
  end

  # DELETE /masquerade
  def destroy
    impersonator = Current.session.impersonator
    impersonated_user = Current.user

    # Destroy the impersonation session
    Current.session.destroy

    # Create a new session as the original admin
    new_session = impersonator.sessions.create!(
      user_agent: request.user_agent,
      ip_address: request.remote_ip
    )

    cookies.signed.permanent[:session_token] = { value: new_session.id, httponly: true }

    log_impersonation_end(impersonated_user) if respond_to?(:log_impersonation_end, true)

    redirect_to admin_users_path, notice: "Stopped masquerading as #{impersonated_user.email}"
  end

  private

  def set_user
    @user = User.find(params[:user_id])
  end

  def authorize_admin
    return if Current.user&.app_admin?

    redirect_to root_path, alert: "Access denied"
  end

  def authorize_impersonation_exit
    return if Current.session&.impersonator.present?

    redirect_to root_path, alert: "Not currently impersonating anyone"
  end

  # Optional audit logging integration
  # These methods are called if audit_log feature is installed
  def log_impersonation_start(impersonated_user)
    return unless defined?(AuditLog)

    AuditLog.create!(
      user: Current.user,
      action: "impersonation_start",
      auditable: impersonated_user,
      ip_address: request.remote_ip,
      user_agent: request.user_agent,
      metadata: { impersonated_email: impersonated_user.email }
    )
  end

  def log_impersonation_end(impersonated_user)
    return unless defined?(AuditLog)

    AuditLog.create!(
      user: Current.session.impersonator,
      action: "impersonation_end",
      auditable: impersonated_user,
      ip_address: request.remote_ip,
      user_agent: request.user_agent,
      metadata: { impersonated_email: impersonated_user.email }
    )
  end
end
