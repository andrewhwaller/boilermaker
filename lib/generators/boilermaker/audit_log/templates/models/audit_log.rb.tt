# frozen_string_literal: true

class AuditLog < ApplicationRecord
  belongs_to :user, optional: true
  belongs_to :auditable, polymorphic: true, optional: true

  validates :action, presence: true
  validates :auditable_type, presence: true

  scope :recent, -> { order(created_at: :desc) }
  scope :for_type, ->(type) { where(auditable_type: type) }
  scope :for_action, ->(action) { where(action: action) }
  scope :for_user, ->(user) { where(user: user) }
  scope :in_date_range, ->(start_date, end_date) { where(created_at: start_date..end_date) }

  # Standard actions
  ACTIONS = %w[create update destroy sign_in sign_out impersonation_start impersonation_end].freeze

  class << self
    def retention_days
      Boilermaker.config.get("features.audit_log_retention_days") || 90
    end

    def cleanup_old_records!
      cutoff_date = retention_days.days.ago
      deleted_count = where("created_at < ?", cutoff_date).delete_all
      Rails.logger.info "[AuditLog] Cleaned up #{deleted_count} records older than #{cutoff_date}"
      deleted_count
    end

    def log(user:, action:, auditable:, changes: {}, metadata: {})
      create!(
        user: user,
        action: action.to_s,
        auditable_type: auditable.class.name,
        auditable_id: auditable.id,
        changes_made: sanitize_changes(changes),
        ip_address: Current.ip_address,
        user_agent: Current.user_agent,
        metadata: metadata
      )
    rescue => e
      Rails.logger.error "[AuditLog] Failed to create audit log: #{e.message}"
      nil
    end

    private

    def sanitize_changes(changes)
      # Filter out sensitive fields from the audit log
      sensitive_fields = %w[password password_digest otp_secret]
      changes.reject { |key, _| sensitive_fields.include?(key.to_s) }
    end
  end

  def human_action
    action.humanize
  end

  def changes_summary
    return "No changes" if changes_made.blank?

    changes_made.map { |key, values| "#{key}: #{values[0]} â†’ #{values[1]}" }.join(", ")
  end
end
